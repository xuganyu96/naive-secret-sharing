#![no_std]
#![allow(non_camel_case_types)]

pub type Word = u16;

/// Carryless multiplciation of words
/// e.g. mul(0b1111, 0b1111) = 15 * 15 = 225 = 0b11100001
///     clmul(0b1111, 0b1111) = 0b1010101
/// TODO: this is not constant time!
pub fn widening_clmul(a: Word, b: Word) -> (Word, Word) {
    let mut prod: (Word, Word) = (0, 0);

    for i in 0..(Word::BITS) {
        if ((1 << i) & b) != 0 {
            // Need to "widening left shift" a by i positions
            let (mut high_bits, overflow) = a.overflowing_shr(Word::BITS - i);
            if overflow {
                high_bits = 0;
            }
            let (mut low_bits, overflow) = a.overflowing_shl(i);
            if overflow {
                low_bits = 0;
            }
            prod = (prod.0 ^ high_bits, prod.1 ^ low_bits);
        }
    }

    return prod;
}

/// Limbs are organized in big-endian bytes order. The limb at smaller index encodes coefficients
/// at higher-power term
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct ExtField2<const L: usize> {
    limbs: [Word; L],
}

impl<const L: usize> ExtField2<L> {
    pub const ZERO: Self = Self::zero();
    pub const ONE: Self = Self::one();
    pub const BITS: usize = (Word::BITS as usize) * L;

    pub const fn as_limbs(&self) -> &[Word] {
        &self.limbs
    }

    pub const fn from_limbs(limbs: [Word; L]) -> Self {
        Self { limbs }
    }

    pub const fn zero() -> Self {
        Self { limbs: [0; L] }
    }

    pub const fn one() -> Self {
        let mut limbs = [0; L];
        limbs[L - 1] = 1;

        Self::from_limbs(limbs)
    }

    /// Equivalent to applying the bitflip operator "!"
    pub fn not(&self) -> Self {
        let mut output = Self::ZERO;

        self.as_limbs()
            .iter()
            .enumerate()
            .for_each(|(i, limb)| output.limbs[i] = !limb);

        return output;
    }

    /// Addition in GF(2^m) is a simple XOR and will never overflow
    #[allow(unused_variables)]
    pub fn gf_add(&self, other: &Self) -> Self {
        let mut limbs = [0; L];

        for i in 0..L {
            // No need for bound check; guaranteed to be within bounds.
            limbs[i] = self.as_limbs()[i] ^ other.as_limbs()[i];
        }

        return Self::from_limbs(limbs);
    }

    /// Subtraction is identical to addition in GF(2^m) because -1 = 1
    pub fn gf_sub(&self, other: &Self) -> Self {
        self.gf_add(other)
    }

    /// School book multiplication with L^2 steps
    #[allow(unused_variables)]
    pub fn widening_gf_mul(&self, other: &Self) -> (Self, Self) {
        let (mut high, mut low) = (Self::ZERO, Self::ZERO);
        for i in 0..L {
            for j in 0..L {
                let (high_limb, low_limb) =
                    widening_clmul(self.limbs[L - i - 1], other.limbs[L - j - 1]);
                if (i + j) < L {
                    low.limbs[L - (i + j) - 1] ^= low_limb;
                } else {
                    high.limbs[L - (i + j - L) - 1] ^= low_limb;
                }
                if (i + j + 1) < L {
                    low.limbs[L - (i + j + 1) - 1] ^= high_limb;
                } else {
                    high.limbs[L - (i + j + 1 - L) - 1] ^= high_limb;
                }
            }
        }

        return (high, low);
    }

    /// modulus multiplication
    #[allow(unused_variables)]
    pub fn gf_modmul(&self, other: &Self, modulus: &Self) -> Self {
        todo!();
    }

    /// Attempt to left shift (e.g. 0xFFFF.overflowing_shl(4) = 0xFFF0)
    /// If the shift amount is greater than there are bits in the
    #[allow(unused_variables)]
    pub fn overflowing_shl(&self, rhs: usize) -> (Self, bool) {
        todo!();
    }

    #[allow(unused_variables)]
    pub fn shr(&self, rhs: usize) -> Self {
        todo!();
    }
}

// TODO: what if I need to implement GF(2^12), such as in classic McEliece
pub type GF_2_16 = ExtField2<1>;
pub type GF_2_128 = ExtField2<8>;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_widening_clmul() {
        assert_eq!(widening_clmul(15, 15), (0, 0b1010101));
        assert_eq!(widening_clmul(0xFFFF, 0xFFFF), (0x5555, 0x5555));
        assert_eq!(widening_clmul(0, 0), (0, 0));
        assert_eq!(widening_clmul(0, 1), (0, 0));
        assert_eq!(widening_clmul(1, 0), (0, 0));
    }

    #[test]
    fn test_extfield_widening_mul() {
        assert_eq!(
            GF_2_128::ZERO.not().widening_gf_mul(&GF_2_128::ZERO),
            (GF_2_128::ZERO, GF_2_128::ZERO)
        );
        // 0xFFFF * 0xFFFF = 0x5555,0x5555
        let fives = GF_2_128::from_limbs([0x5555; 8]);
        assert_eq!(
            GF_2_128::ZERO.not().widening_gf_mul(&GF_2_128::ZERO.not()),
            (fives, fives)
        );

        // Random cases generated by SymPy
        let lhs = GF_2_128::from_limbs([
            0x37F9, 0xE4A4, 0xF3F1, 0x0ABE, 0xDF66, 0xF040, 0xCBBF, 0x8357,
        ]);
        let rhs = GF_2_128::from_limbs([
            0x7F49, 0x6878, 0x645D, 0x7EE7, 0x7AD0, 0xBD91, 0x06EC, 0x3A2D,
        ]);
        let prod = (
            GF_2_128::from_limbs([
                0x094A, 0x8595, 0x1C1B, 0x96A7, 0x04CB, 0x69B4, 0xF155, 0xE780,
            ]),
            GF_2_128::from_limbs([
                0x325F, 0x4B8F, 0x7DC6, 0x4E68, 0xD15E, 0x2225, 0xB54A, 0x7853,
            ]),
        );
        assert_eq!(lhs.widening_gf_mul(&rhs), prod);
        let lhs = GF_2_128::from_limbs([
            0xDC9B, 0x045A, 0x1C13, 0xA8E7, 0xD74C, 0xCF70, 0xACB2, 0xE1FD,
        ]);
        let rhs = GF_2_128::from_limbs([
            0x2098, 0x0F39, 0x47B7, 0xC309, 0x7DAB, 0xC8A9, 0x5E4B, 0x58CF,
        ]);
        let prod = (
            GF_2_128::from_limbs([
                0x1BF6, 0x0482, 0x471A, 0xBB23, 0x1597, 0xF446, 0x12C6, 0x58C0,
            ]),
            GF_2_128::from_limbs([
                0xE68C, 0x240A, 0xBF93, 0xE1FE, 0xCD7D, 0xC416, 0x807A, 0xEAE9,
            ]),
        );
        assert_eq!(lhs.widening_gf_mul(&rhs), prod);
    }
}
